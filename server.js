const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');
const crypto = require('crypto');
const cloudinary = require('cloudinary').v2;
const mongoose = require('mongoose');
const { Buffer } = require('buffer');

const app = express();
const server = http.createServer(app);
const PORT = process.env.PORT || 10000;

// Environment Variables - Render'da ayarlanacak
const MONGODB_URI = process.env.MONGODB_URI;
const CLOUDINARY_CLOUD_NAME = process.env.CLOUDINARY_CLOUD_NAME;
const CLOUDINARY_API_KEY = process.env.CLOUDINARY_API_KEY;
const CLOUDINARY_API_SECRET = process.env.CLOUDINARY_API_SECRET;

// Cloudinary configuration - Varsa config et
if (CLOUDINARY_CLOUD_NAME && CLOUDINARY_API_KEY && CLOUDINARY_API_SECRET) {
  cloudinary.config({
    cloud_name: CLOUDINARY_CLOUD_NAME,
    api_key: CLOUDINARY_API_KEY,
    api_secret: CLOUDINARY_API_SECRET
  });
  console.log('‚úÖ Cloudinary configured');
} else {
  console.log('‚ö†Ô∏è Cloudinary not configured - using base64 fallback');
}

// MongoDB connection with better error handling
async function connectDB() {
  if (!MONGODB_URI) {
    console.log('‚ùå MONGODB_URI not found in environment variables');
    console.log('üìù Using in-memory storage (data will be lost on restart)');
    return false;
  }

  try {
    await mongoose.connect(MONGODB_URI);
    console.log('‚úÖ MongoDB baƒülantƒ±sƒ± ba≈üarƒ±lƒ±');
    return true;
  } catch (error) {
    console.error('‚ùå MongoDB baƒülantƒ± hatasƒ±:', error.message);
    console.log('üìù Using in-memory storage (data will be lost on restart)');
    return false;
  }
}

// MongoDB Schemas
const roomSchema = new mongoose.Schema({
  code: { type: String, unique: true, required: true },
  name: { type: String, required: true },
  password: String,
  owner: { type: String, required: true },
  activeVideo: {
    url: String,
    title: String,
    cloudinaryId: String,
    uploadedBy: String,
    uploadedAt: Date
  },
  playbackState: {
    playing: Boolean,
    currentTime: Number,
    playbackRate: Number
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

const userSchema = new mongoose.Schema({
  socketId: { type: String, required: true },
  userName: { type: String, required: true },
  userPhoto: String,
  userColor: String,
  deviceId: String,
  roomCode: String,
  isOwner: Boolean,
  country: String,
  lastSeen: { type: Date, default: Date.now }
});

const messageSchema = new mongoose.Schema({
  roomCode: { type: String, required: true },
  userName: { type: String, required: true },
  userPhoto: String,
  userColor: String,
  text: { type: String, required: true },
  type: { type: String, default: 'text' },
  time: String,
  country: String,
  createdAt: { type: Date, default: Date.now }
});

const Room = mongoose.model('Room', roomSchema);
const User = mongoose.model('User', userSchema);
const Message = mongoose.model('Message', messageSchema);

// In-memory storage fallback
const memoryRooms = new Map();
const memoryUsers = new Map();
const memoryMessages = new Map(); // roomCode -> messages array

let useDatabase = false;

// Render i√ßin CORS ayarlarƒ±
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

// Middleware
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));
app.use(express.static(path.join(__dirname, 'public')));

// Yardƒ±mcƒ± fonksiyonlar
function generateRoomCode() {
  return crypto.randomBytes(3).toString('hex').toUpperCase();
}

function sanitizeUser(user) {
  return {
    id: user.socketId,
    userName: user.userName,
    userPhoto: user.userPhoto,
    userColor: user.userColor,
    isOwner: user.isOwner,
    country: user.country || 'T√ºrkiye',
    deviceId: user.deviceId
  };
}

// Cloudinary'ye video y√ºkleme fonksiyonu
async function uploadToCloudinary(videoBase64, fileName) {
  if (!CLOUDINARY_CLOUD_NAME || !CLOUDINARY_API_KEY || !CLOUDINARY_API_SECRET) {
    throw new Error('Cloudinary not configured');
  }

  try {
    console.log('‚òÅÔ∏è Cloudinary\'ye video y√ºkleniyor...');
    
    const result = await cloudinary.uploader.upload(videoBase64, {
      resource_type: 'video',
      public_id: `video-platform/${Date.now()}-${crypto.randomBytes(4).toString('hex')}`,
      chunk_size: 6000000,
      timeout: 120000,
    });

    console.log('‚úÖ Cloudinary y√ºkleme ba≈üarƒ±lƒ±:', result.public_id);
    return result;
  } catch (error) {
    console.error('‚ùå Cloudinary y√ºkleme hatasƒ±:', error);
    throw error;
  }
}

// Database functions with fallback
async function saveRoom(roomData) {
  if (useDatabase) {
    const room = new Room(roomData);
    return await room.save();
  } else {
    memoryRooms.set(roomData.code, { ...roomData, _id: crypto.randomBytes(8).toString('hex') });
    return memoryRooms.get(roomData.code);
  }
}

async function findRoom(roomCode) {
  if (useDatabase) {
    return await Room.findOne({ code: roomCode });
  } else {
    return memoryRooms.get(roomCode) || null;
  }
}

async function updateRoom(roomCode, updateData) {
  if (useDatabase) {
    return await Room.findOneAndUpdate(
      { code: roomCode },
      { ...updateData, updatedAt: new Date() },
      { new: true }
    );
  } else {
    const room = memoryRooms.get(roomCode);
    if (room) {
      Object.assign(room, updateData, { updatedAt: new Date() });
      memoryRooms.set(roomCode, room);
    }
    return room;
  }
}

async function saveUser(userData) {
  if (useDatabase) {
    const user = new User(userData);
    return await user.save();
  } else {
    memoryUsers.set(userData.socketId, { ...userData, _id: crypto.randomBytes(8).toString('hex') });
    return memoryUsers.get(userData.socketId);
  }
}

async function findUser(socketId) {
  if (useDatabase) {
    return await User.findOne({ socketId });
  } else {
    return memoryUsers.get(socketId) || null;
  }
}

async function deleteUser(socketId) {
  if (useDatabase) {
    await User.deleteOne({ socketId });
  } else {
    memoryUsers.delete(socketId);
  }
}

async function findUsersByRoom(roomCode) {
  if (useDatabase) {
    return await User.find({ roomCode });
  } else {
    return Array.from(memoryUsers.values()).filter(user => user.roomCode === roomCode);
  }
}

async function saveMessage(messageData) {
  if (useDatabase) {
    const message = new Message(messageData);
    return await message.save();
  } else {
    const message = { ...messageData, _id: crypto.randomBytes(8).toString('hex'), createdAt: new Date() };
    if (!memoryMessages.has(messageData.roomCode)) {
      memoryMessages.set(messageData.roomCode, []);
    }
    memoryMessages.get(messageData.roomCode).push(message);
    return message;
  }
}

async function findMessagesByRoom(roomCode, limit = 50) {
  if (useDatabase) {
    return await Message.find({ roomCode }).sort({ createdAt: -1 }).limit(limit);
  } else {
    const messages = memoryMessages.get(roomCode) || [];
    return messages.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).slice(0, limit);
  }
}

async function deleteRoom(roomCode) {
  if (useDatabase) {
    await Room.deleteOne({ code: roomCode });
    await Message.deleteMany({ roomCode });
  } else {
    memoryRooms.delete(roomCode);
    memoryMessages.delete(roomCode);
  }
}

// Socket.io baƒülantƒ± y√∂netimi
io.on('connection', (socket) => {
  console.log('üîó Yeni kullanƒ±cƒ± baƒülandƒ±:', socket.id);

  let currentUser = null;
  let currentRoom = null;

  // Oda olu≈üturma
  socket.on('create-room', async (data) => {
    try {
      const { userName, userPhoto, deviceId, roomName, password } = data;
      
      const roomCode = generateRoomCode();
      
      // Oda olu≈ütur
      const room = await saveRoom({
        code: roomCode,
        name: roomName,
        password: password,
        owner: socket.id,
        playbackState: {
          playing: false,
          currentTime: 0,
          playbackRate: 1
        }
      });
      
      // Kullanƒ±cƒ± olu≈ütur
      currentUser = await saveUser({
        socketId: socket.id,
        userName: userName || 'Anonim',
        userPhoto: userPhoto,
        userColor: `hsl(${Math.random() * 360}, 70%, 60%)`,
        deviceId: deviceId,
        roomCode: roomCode,
        isOwner: true,
        country: 'T√ºrkiye'
      });
      
      currentRoom = room;
      socket.join(roomCode);
      
      // Ba≈üarƒ±lƒ± yanƒ±t
      socket.emit('room-created', {
        roomCode: room.code,
        roomName: room.name,
        isOwner: true
      });
      
      console.log(`‚úÖ Oda olu≈üturuldu: ${room.code} - ${room.name}`);
      
    } catch (error) {
      console.error('‚ùå Oda olu≈üturma hatasƒ±:', error);
      socket.emit('error', { message: 'Oda olu≈üturulamadƒ±' });
    }
  });

  // Odaya katƒ±lma
  socket.on('join-room', async (data) => {
    try {
      const { roomCode, userName, userPhoto, deviceId, password } = data;
      
      const room = await findRoom(roomCode);
      if (!room) {
        socket.emit('error', { message: 'Oda bulunamadƒ±' });
        return;
      }
      
      // ≈ûifre kontrol√º
      if (room.password && room.password !== password) {
        socket.emit('error', { message: 'Ge√ßersiz ≈üifre' });
        return;
      }
      
      // Kullanƒ±cƒ± olu≈ütur/g√ºncelle
      currentUser = await saveUser({
        socketId: socket.id,
        userName: userName || 'Anonim',
        userPhoto: userPhoto,
        userColor: `hsl(${Math.random() * 360}, 70%, 60%)`,
        deviceId: deviceId,
        roomCode: roomCode,
        isOwner: false,
        country: 'T√ºrkiye',
        lastSeen: new Date()
      });
      
      currentRoom = room;
      socket.join(roomCode);
      
      // Ge√ßmi≈ü mesajlarƒ± getir
      const messages = await findMessagesByRoom(roomCode);
      
      // Ba≈üarƒ±lƒ± yanƒ±t
      socket.emit('room-joined', {
        roomCode: room.code,
        roomName: room.name,
        isOwner: false,
        activeVideo: room.activeVideo,
        playbackState: room.playbackState,
        userColor: currentUser.userColor,
        previousMessages: messages.reverse()
      });
      
      // Diƒüer kullanƒ±cƒ±lara bildir
      socket.to(roomCode).emit('user-joined', {
        userName: currentUser.userName
      });
      
      // Kullanƒ±cƒ± listesini g√ºncelle
      await updateUserList(roomCode);
      
      console.log(`‚úÖ Kullanƒ±cƒ± odaya katƒ±ldƒ±: ${userName} -> ${roomCode}`);
      
    } catch (error) {
      console.error('‚ùå Odaya katƒ±lma hatasƒ±:', error);
      socket.emit('error', { message: 'Odaya katƒ±lamadƒ±' });
    }
  });

  // Video y√ºkleme
  socket.on('upload-video', async (data) => {
    try {
      if (!currentRoom || !currentUser || !currentUser.isOwner) {
        socket.emit('error', { message: 'Video y√ºklemek i√ßin oda sahibi olmalƒ±sƒ±nƒ±z' });
        return;
      }
      
      const { videoBase64, title } = data;
      
      let videoUrl = videoBase64;
      let cloudinaryId = null;
      
      // Cloudinary'ye y√ºkle (eƒüer config varsa)
      if (CLOUDINARY_CLOUD_NAME && CLOUDINARY_API_KEY && CLOUDINARY_API_SECRET) {
        try {
          console.log(`üé¨ Cloudinary'ye video y√ºkleniyor: ${title}`);
          const cloudinaryResult = await uploadToCloudinary(videoBase64, title);
          videoUrl = cloudinaryResult.secure_url;
          cloudinaryId = cloudinaryResult.public_id;
        } catch (error) {
          console.log('‚ö†Ô∏è Cloudinary y√ºkleme ba≈üarƒ±sƒ±z, base64 kullanƒ±lƒ±yor:', error.message);
          // Cloudinary ba≈üarƒ±sƒ±z olursa base64 kullanmaya devam et
        }
      }
      
      // Odayƒ± g√ºncelle
      await updateRoom(currentRoom.code, {
        activeVideo: {
          url: videoUrl,
          title: title || 'Video',
          cloudinaryId: cloudinaryId,
          uploadedBy: currentUser.userName,
          uploadedAt: new Date()
        },
        playbackState: {
          playing: false,
          currentTime: 0,
          playbackRate: 1
        }
      });
      
      // T√ºm kullanƒ±cƒ±lara video y√ºklendiƒüini bildir
      io.to(currentRoom.code).emit('video-uploaded', {
        videoUrl: videoUrl,
        title: title || 'Video',
        cloudinaryId: cloudinaryId
      });
      
      console.log(`üé¨ Video y√ºklendi: ${title} -> ${currentRoom.code}`);
      
    } catch (error) {
      console.error('‚ùå Video y√ºkleme hatasƒ±:', error);
      socket.emit('error', { message: 'Video y√ºklenemedi: ' + error.message });
    }
  });

  // Video kontrol√º
  socket.on('video-control', async (controlData) => {
    if (!currentRoom || !currentUser || !currentUser.isOwner) return;
    
    try {
      await updateRoom(currentRoom.code, {
        playbackState: {
          playing: controlData.playing,
          currentTime: controlData.currentTime,
          playbackRate: controlData.playbackRate
        }
      });
      
      // Oda sahibi dƒ±≈üƒ±ndaki herkese kontrol bilgilerini g√∂nder
      socket.to(currentRoom.code).emit('video-control', controlData);
    } catch (error) {
      console.error('‚ùå Video kontrol g√ºncelleme hatasƒ±:', error);
    }
  });

  // Video silme
  socket.on('delete-video', async () => {
    if (!currentRoom || !currentUser || !currentUser.isOwner) return;
    
    try {
      // Cloudinary'den video sil (eƒüer varsa)
      if (currentRoom.activeVideo && currentRoom.activeVideo.cloudinaryId) {
        try {
          await cloudinary.uploader.destroy(currentRoom.activeVideo.cloudinaryId, {
            resource_type: 'video'
          });
        } catch (error) {
          console.log('‚ö†Ô∏è Cloudinary silme ba≈üarƒ±sƒ±z:', error.message);
        }
      }
      
      // Odayƒ± g√ºncelle
      await updateRoom(currentRoom.code, {
        activeVideo: null,
        playbackState: {
          playing: false,
          currentTime: 0,
          playbackRate: 1
        }
      });
      
      io.to(currentRoom.code).emit('video-deleted');
      console.log(`üóëÔ∏è Video silindi: ${currentRoom.code}`);
      
    } catch (error) {
      console.error('‚ùå Video silme hatasƒ±:', error);
    }
  });

  // Mesaj g√∂nderme
  socket.on('message', async (messageData) => {
    try {
      if (!currentRoom || !currentUser) return;
      
      console.log('üí¨ Mesaj alƒ±ndƒ±:', messageData.text);
      
      const message = await saveMessage({
        roomCode: currentRoom.code,
        userName: currentUser.userName,
        userPhoto: currentUser.userPhoto,
        userColor: currentUser.userColor,
        text: messageData.text,
        type: messageData.type || 'text',
        time: new Date().toLocaleTimeString('tr-TR', { 
          hour: '2-digit', 
          minute: '2-digit' 
        }),
        country: currentUser.country
      });
      
      // T√ºm kullanƒ±cƒ±lara mesajƒ± g√∂nder
      io.to(currentRoom.code).emit('message', {
        id: message._id,
        userName: currentUser.userName,
        userPhoto: currentUser.userPhoto,
        userColor: currentUser.userColor,
        text: messageData.text,
        type: messageData.type || 'text',
        time: message.time,
        country: currentUser.country
      });
      
      console.log(`üí¨ Mesaj kaydedildi: ${currentUser.userName} -> ${messageData.text}`);
      
    } catch (error) {
      console.error('‚ùå Mesaj g√∂nderme hatasƒ±:', error);
    }
  });

  // Kullanƒ±cƒ± listesini g√ºncelleme fonksiyonu
  async function updateUserList(roomCode) {
    try {
      const users = await findUsersByRoom(roomCode);
      const userList = users.map(user => sanitizeUser(user));
      io.to(roomCode).emit('user-list-update', userList);
    } catch (error) {
      console.error('‚ùå Kullanƒ±cƒ± listesi g√ºncelleme hatasƒ±:', error);
    }
  }

  // Baƒülantƒ± kesildiƒüinde
  socket.on('disconnect', async (reason) => {
    console.log('üîå Kullanƒ±cƒ± ayrƒ±ldƒ±:', socket.id, 'Sebep:', reason);
    
    if (currentUser) {
      try {
        // Kullanƒ±cƒ±yƒ± sil
        await deleteUser(socket.id);
        
        if (currentRoom) {
          // Diƒüer kullanƒ±cƒ±lara bildir
          socket.to(currentRoom.code).emit('user-left', {
            userName: currentUser.userName
          });
          
          // Eƒüer oda sahibi ayrƒ±ldƒ±ysa kontrol et
          if (currentUser.isOwner) {
            const roomUsers = await findUsersByRoom(currentRoom.code);
            if (roomUsers.length === 0) {
              // Odada kimse kalmadƒ±, odayƒ± temizle
              await deleteRoom(currentRoom.code);
              console.log(`üóëÔ∏è Oda silindi: ${currentRoom.code}`);
            }
          } else {
            // Kullanƒ±cƒ± listesini g√ºncelle
            await updateUserList(currentRoom.code);
          }
        }
      } catch (error) {
        console.error('‚ùå Kullanƒ±cƒ± temizleme hatasƒ±:', error);
      }
    }
  });
});

// API Routes
app.get('/api/health', async (req, res) => {
  try {
    let roomCount, userCount, messageCount;
    
    if (useDatabase) {
      roomCount = await Room.countDocuments();
      userCount = await User.countDocuments();
      messageCount = await Message.countDocuments();
    } else {
      roomCount = memoryRooms.size;
      userCount = memoryUsers.size;
      messageCount = Array.from(memoryMessages.values()).reduce((acc, msgs) => acc + msgs.length, 0);
    }
    
    res.json({ 
      status: 'OK', 
      timestamp: new Date().toISOString(),
      rooms: roomCount,
      users: userCount,
      messages: messageCount,
      environment: process.env.NODE_ENV || 'development',
      database: useDatabase ? 'MongoDB' : 'In-Memory',
      cloudinary: !!(CLOUDINARY_CLOUD_NAME && CLOUDINARY_API_KEY && CLOUDINARY_API_SECRET)
    });
  } catch (error) {
    res.status(500).json({ error: 'Health check failed' });
  }
});

app.get('/api/rooms', async (req, res) => {
  try {
    let rooms;
    
    if (useDatabase) {
      rooms = await Room.find().select('code name createdAt updatedAt').lean();
    } else {
      rooms = Array.from(memoryRooms.values()).map(room => ({
        code: room.code,
        name: room.name,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      }));
    }
    
    const roomList = await Promise.all(rooms.map(async (room) => {
      const users = await findUsersByRoom(room.code);
      return {
        code: room.code,
        name: room.name,
        userCount: users.length,
        hasPassword: !!room.password,
        createdAt: room.createdAt,
        updatedAt: room.updatedAt
      };
    }));
    
    res.json(roomList);
  } catch (error) {
    res.status(500).json({ error: 'Rooms fetch failed' });
  }
});

// Static files
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Ba≈ülatma
async function startServer() {
  // MongoDB'ye baƒülan
  useDatabase = await connectDB();
  
  server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ Server ${PORT} portunda √ßalƒ±≈üƒ±yor`);
    console.log(`üåê Environment: ${process.env.NODE_ENV || 'development'}`);
    console.log(`üóÑÔ∏è Database: ${useDatabase ? 'MongoDB' : 'In-Memory'}`);
    console.log(`‚òÅÔ∏è Cloudinary: ${CLOUDINARY_CLOUD_NAME ? 'Configured' : 'Not configured'}`);
  });
}

startServer();

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('üõë SIGTERM alƒ±ndƒ±, server kapatƒ±lƒ±yor...');
  server.close(async () => {
    if (useDatabase) {
      await mongoose.connection.close();
    }
    console.log('‚úÖ Server ba≈üarƒ±yla kapatƒ±ldƒ±');
    process.exit(0);
  });
});
